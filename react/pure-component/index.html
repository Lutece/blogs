<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="preload" href="/component---src-layouts-index-js-2485bbdc1218129f193c.js" as="script"/><link rel="preload" href="/component---src-templates-post-js-1681630183b3d64fa2ec.js" as="script"/><link rel="preload" href="/path---react-pure-component-5a740d22279f1b254353.js" as="script"/><link rel="preload" href="/app-e7b818c751a53d938e4c.js" as="script"/><link rel="preload" href="/commons-79baf21cb474f27d4109.js" as="script"/><script id="webpack-manifest">/*<![CDATA[*/window.webpackManifest={"231608221292675":"app-e7b818c751a53d938e4c.js","195351340454287":"component---src-templates-post-js-1681630183b3d64fa2ec.js","162898551421021":"component---src-pages-404-js-4503918ea3a16cfcdb75.js","35783957827783":"component---src-pages-index-js-8cf12e248c651af9b994.js","166261876811483":"component---src-pages-js-index-js-c5d8fa2e541047965be7.js","28963048177478":"component---src-pages-css-flex-js-6ec30cf0106df8b8d49c.js","217397819687451":"component---src-pages-css-index-js-eb2d1780ed52526a0b83.js","42763218332526":"component---src-pages-js-es-5-constructor-js-9ac2ea2cf64f2f850597.js","105213442783835":"component---src-pages-js-es-5-index-js-b82dce44ceeb5b57b276.js","60335399758886":"path----557518bd178906f8d58a.js","103224921071788":"path---react-pure-component-5a740d22279f1b254353.js","32954286527539":"path---react-combine-component-container-presentation-80c966f53352e2a9bf3e.js","137628902668530":"path---react-combine-component-e250e0f6890bdf3cfc7c.js","158595016466780":"path---react-1-277fbecad07d582d5fcb.js","166576313575497":"path---js-constructor-312a69b7424ef51aeccb.js","254022195166212":"path---404-a0e39f21c11f6a62c5ab.js","142629428675168":"path---index-a0e39f21c11f6a62c5ab.js","178698757827068":"path---404-html-a0e39f21c11f6a62c5ab.js","19859913514536":"path---js-a0e39f21c11f6a62c5ab.js","236614003138850":"path---css-flex-a0e39f21c11f6a62c5ab.js","84503659841496":"path---css-a0e39f21c11f6a62c5ab.js","21545007731718":"path---js-es-5-constructor-a0e39f21c11f6a62c5ab.js","244910650413466":"path---js-es-5-a0e39f21c11f6a62c5ab.js","114276838955818":"component---src-layouts-index-js-2485bbdc1218129f193c.js"}/*]]>*/</script><script>/*<![CDATA[*/!function(e,t,r){function n(){for(;d[0]&&"loaded"==d[0][f];)c=d.shift(),c[o]=!i.parentNode.insertBefore(c,i)}for(var s,a,c,d=[],i=e.scripts[0],o="onreadystatechange",f="readyState";s=r.shift();)a=e.createElement(t),"async"in i?(a.async=!1,e.head.appendChild(a)):i[f]?(d.push(a),a[o]=n):e.write("<"+t+' src="'+s+'" defer></'+t+">"),a.src=s}(document,"script",["/commons-79baf21cb474f27d4109.js","/app-e7b818c751a53d938e4c.js","/path---react-pure-component-5a740d22279f1b254353.js","/component---src-templates-post-js-1681630183b3d64fa2ec.js","/component---src-layouts-index-js-2485bbdc1218129f193c.js"])/*]]>*/</script><style id="gatsby-inlined-css">body,html{width:100%;height:100%;margin:0;padding:0}body{padding-bottom:3em;background:#20232b;font-family:Titillium Web,Helvetica Neue,Helvetica,Arial,Microsoft Yahei,sans-serif;font-size:24px;font-weight:300}ul{margin:0 1.2em}li,ul{padding:0}li{margin:0;list-style-type:hangul}code,strong{font-weight:400}header{padding:.7em 0;background:#20232b;font-size:24px;color:#61dafb}.header--container{padding:0 1em}.header--title{margin:0;padding:0;font-size:.8em;font-weight:400}.header--title+p{padding:1rem 0;border-top:1px solid #61dafb;border-bottom:1px solid #61dafb}.header--link{text-decoration:none}.header--link:visited{color:#61dafb}.header--category{display:flex;justify-content:space-around;margin:4rem 0 3rem;padding:0}.header--category li{padding:.5rem 1.3rem;border:1px solid #000;cursor:pointer}@media screen and (max-width:767px){.header--title{font-size:2rem}.header--title+p{margin:1.1em 1.6rem 0;padding:1rem;font-size:1.3rem}.header--category li{font-size:1rem;padding:.5rem 1.3rem}}footer{height:10em;text-align:center;line-height:10em;font-size:.7em;font-weight:300;color:#999}code[class*=language-],pre[class*=language-]{color:#f8f8f2;background:none;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#272822}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#f8f8f2}.namespace{opacity:.7}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#f92672}.token.boolean,.token.number{color:#ae81ff}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a6e22e}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#f8f8f2}.token.atrule,.token.attr-value,.token.function{color:#e6db74}.token.keyword{color:#66d9ef}.token.important,.token.regex{color:#fd971f}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.blog-post-container{background:#282c34}.blog-post-container .gatsby-highlight{padding:2em 0}.blog-post-container .blog--title{padding:4em 0}.blog-post-container .blog-post h1{margin:0 9.3rem;padding:.88rem 0;border-top:1px solid #61dafb;border-bottom:1px solid #61dafb;font-size:1.1em;color:#61dafb}.blog-post-container .blog-post h2{font-size:.8em;color:#61dafb}.blog-post-container .blog-post-content{padding:4em 6em;background:#fff;text-align:left;font-size:1.2rem}.blog-post-container .blog-post-content hr{margin:4rem 0}.blog-post-container .disqusContainer{padding:2em 4em;background:#fff;color:#000}@media screen and (min-width:1240px){.blog-post-container .blog-post h1{margin:0 15rem}}@media screen and (max-width:767px){.blog-post h1{margin:0 1.6rem;padding:1rem;font-size:1.3rem}.blog-post-container{width:600px}}</style></head><body><div id="___gatsby"><div data-reactroot="" data-reactid="1" data-react-checksum="909917438"><header data-reactid="2"><div class="header--container" data-reactid="3"><h1 class="header--title" data-reactid="4"><a class="header--link" href="/" data-reactid="5">Lutece</a></h1><p style="display:none;" data-reactid="6">프론트엔드 개발 경험을 기록하는 블로그입니다.</p></div></header><div style="margin:0 auto;padding-top:0;text-align:center;" data-reactid="7"><div class="blog-post-container" data-reactid="8"><div class="blog-post" data-reactid="9"><div class="blog--title" data-reactid="10"><h1 data-reactid="11">Deep Copy와 Shallow Copy, Pure Component</h1><h2 data-reactid="12">February 09, 2018</h2></div><div class="blog-post-content" data-reactid="13"><h3>Agenda</h3>
<ul>
<li>Shallow Copy와 Deep Copy</li>
<li>React.Component 와 React.PureComponent의 차이</li>
</ul>
<hr>
<h3>Shallow Copy is</h3>
<p>우리는 값의 ‘복제’라는 개념을 생각할 때 ‘별개의 것’이라고 예상합니다. </p>
<p>즉, 복제가 진행되면 복제된 대상과 원본은 서로 영향을 끼치지 않는 다는 것을 의미합니다.</p>
<p>‘Shallow’라는 단어의 의미는 <strong>물리적으로 두께 또는 깊이 따위가 얕다</strong>라는 뜻을 갖고 있습니다. (얄팍하다 라는 뜻도 있다.)</p>
<p>다시 말해, ‘Shallow Copy’는 <strong>객체의 복제 과정이 깊지 않음</strong>을 의미합니다.</p>
<p>아래의 예제를 살펴보면 Shallow Copy의 의미를 이해할 수 있습니다.</p>
<div class="gatsby-highlight">
      <pre class="language-javascript"><code>    <span class="token keyword">let</span> originalObj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span>c<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> shallowCopyObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> originalObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    shallowCopyObj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>originalObj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token comment">// output 3 : 복제의 원본이 되는 객체의 프로퍼티 값이 바뀐다.</span>
</code></pre>
      </div>
<p>‘Shallow Copy’가 진행될 때 ‘복제’하려는 값이 참조 타입인 객체이고 그 객체의 내부 프로퍼티가 ‘참조 타입’인 값이 존재하는 경우,</p>
<p>참조 값은 프로퍼티가 그대로 유지된 채 새로운 객체가 생성됩니다.</p>
<p>`Shallow Copy’가 진행되어 만들어진 복제된 객체의 프로퍼티와, 원본의 프로퍼티는 서로 같은 것을 가리키게 됩니다.</p>
<p>따라서 참조 타입 값을 프로퍼티로 갖고 있는 객체를 복제할 때는 </p>
<p>프로퍼티들도 모두 온전히 복제가 이루어져야 하는 지에 대해 한번 더 생각해 볼 필요성이 있습니다.</p>
<p>참조 값인 프로퍼티들 또한 복제가 이루어지는 과정을 ‘Deep Copy’라고 합니다.</p>
<hr>
<h3>Deep Copy is</h3>
<p>‘Deep Copy’에서 ‘Deep’은 ‘Shallow’와는 반대의 표현입니다. 즉, ‘깊다.(물리적으로)‘를 의미합니다.</p>
<p>그럼 ‘Deep Copy’의 과정이 ‘Shallow Copy’와 다른 점을 생각해봅시다.</p>
<p>‘Shallow Copy’는 복제하는 대상이 객체일 경우 새로운 객체를 만들고 그 객체가 갖고 있는 내부를 복제하는 과정을 한번만 거치며 끝이 납니다.</p>
<p>여기서 주목할 것은 복제하는 대상이 참조 타입인 ‘객체’임을 확인하고 객체일 경우 새로운 객체를 만드는 과정입니다.</p>
<p>‘Shallow Copy’는 객체인지를 확인하고 새로운 객체를 할당하는 과정을 원본 객체 자체만 거치고,</p>
<p>‘Deep Copy’는 원본 객체의 프로퍼티들을 모두 거친다는 차이점이 있습니다.</p>
<div class="gatsby-highlight">
      <pre class="language-javascript"><code>    <span class="token comment">//Deep Copy의미를 clone으로 대체하여 표현하기도 있습니다. </span>
    <span class="token keyword">function</span> <span class="token function">cloneObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> cloneObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>  <span class="token keyword">typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                cloneObj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">cloneObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                cloneObj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> cloneObj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> originalObj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span>c<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> shallowCopyObj <span class="token operator">=</span> <span class="token function">cloneObject</span><span class="token punctuation">(</span>originalObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shallowCopyObj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>originalObj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output 2</span>
</code></pre>
      </div>
<hr>
<h3>Component is</h3>
<p>React에서 컴포넌트는 어플리케이션을 구성하는 ‘단위’라고 할 수 있습니다.</p>
<p>예를 들어 Todo 앱을 만든다고 가정하면 여러가지 기준을 통해 어플리케이션을 나눠 컴포넌트를 관리할 수 있습니다.</p>
<p>React는 여러 컴포넌트들의 조합으로 어플리케이션을 만듭니다.</p>
<p>React의 컴포넌트들은 부모-자식 관계를 만들 수 있으며, </p>
<p><img src="http://blog.mgechev.com/images/overview-components/component-tree.png" alt="Image"></p>
<p>기본적인 컴포넌트는 React 라이브러리 내에 있는 <strong>Component</strong>를 상속을 통해 구현할 수 있습니다.</p>
<p>컴포넌트들 사이에 부모-자식 관계가 생성되면 데이터를 주고 받을 수 있으며 <strong>One-way data flow</strong>입니다.</p>
<div class="gatsby-highlight">
      <pre class="language-jsx"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Normal</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>
        This is just Component
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p>기본적으로 부모의 컴포넌트가 Rendering 되면 자식 컴포넌트도 함께 Rendering 됩니다.</p>
<p>그러나 무조건적인 Rendering은 비효율적이기 때문에 React의 컴포넌트는 Rendering을 통제할 수 있는 메서드를 갖고 있습니다.</p>
<p><strong>shouldComponentUpdate</strong>라는 메서드를 통해 컴포넌트의 Rendering을 컨트롤할 수 있습니다.</p>
<p><strong>shouldComponentUpdate</strong>라는 메서드는 인자로 nextProps와 nextState를 받으며,</p>
<p>Return 값으로 true , false 넘기며 true, false 여부에 따라 컴포넌트를 Rendering 합니다.</p>
<p>React의 <strong>Component</strong>를 통해 만들어진 컴포넌트는 기본적으로 <strong>shouldComponentUpdate</strong>를 실행하지 않습니다.</p>
<p>그렇기 때문에 무조건적인 Rendering을 막기 위해서는 <strong>shouldComponentUpdate</strong>를 따로 구현하여 통제하거나, 컴포넌트를 재설계해야하는 과정이 필요합니다.</p>
<hr>
<h3>PureComponent is</h3>
<p>컴포넌트의 종류 중 <strong>PureComponent</strong>라는 것이 존재합니다.</p>
<p>이것은 React 라이브러리 내에 있으며 컴포넌트를 만들 때 <strong>Component</strong>대신 사용할 수 있습니다.</p>
<p>이 둘의 차이는 <strong>shouldComponentUpdate</strong>의 <strong>실행여부</strong> 입니다.</p>
<p><strong>PureComponent</strong>를 통해 컴포넌트를 만들면 컴포넌트 렌더링 시점에 <strong>shouldComponentUpdate</strong>를 실행하게 되는데,</p>
<p><strong>PureComponent</strong>는 props와 state를 캐싱합니다.</p>
<p>캐싱된 props와 state를 새로 들어온 props, state외 <strong>Shallow Comparison</strong>(얕은 비교를) 하여 Rendering 여부를 판단합니다.</p>
<p>Rendering 시점에서 props나 state의 변화가 없으면 컴포넌트를 Rendering 하지 않습니다.</p>
<p>여기서 주의해야 할 점은 <strong>Shallow Comparison</strong>(얕은 비교)이기 때문에 props와 state의 데이터 구조가 복잡한 형태일 경우,</p>
<p>컴포넌트의 Rendering 시점이 원하지 않는 방향으로 판단될 수 있습니다.</p>
<p><a href="https://reactjs.org/docs/react-api.html#reactpurecomponent">참조 링크</a></p></div></div><div class="disqusContainer" data-reactid="14"><div data-reactid="15"><div id="disqus_thread" data-reactid="16"></div></div></div></div></div><footer data-reactid="17">Copyright © 2018 Lutece.</footer></div></div><script>
  
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-96449606-2', 'auto');
  </script></body></html>