{"version":3,"sources":["webpack:///path---react-pure-component-5a740d22279f1b254353.js","webpack:///./.cache/json/react-pure-component.json"],"names":["webpackJsonp","319","module","exports","data","markdownRemark","html","frontmatter","date","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,8pUAAq+RC,aAAqhDC,KAAA,oBAAAC,KAAA,wBAAAC,MAAA,6CAA8GC","file":"path---react-pure-component-5a740d22279f1b254353.js","sourcesContent":["webpackJsonp([103224921071788],{\n\n/***/ 319:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h3>Agenda</h3>\\n<ul>\\n<li>Shallow Copy와 Deep Copy</li>\\n<li>React.Component 와 React.PureComponent의 차이</li>\\n</ul>\\n<hr>\\n<h3>Shallow Copy is</h3>\\n<p>우리는 값의 ‘복제’라는 개념을 생각할 때 ‘별개의 것’이라고 예상합니다. </p>\\n<p>즉, 복제가 진행되면 복제된 대상과 원본은 서로 영향을 끼치지 않는 다는 것을 의미합니다.</p>\\n<p>‘Shallow’라는 단어의 의미는 <strong>물리적으로 두께 또는 깊이 따위가 얕다</strong>라는 뜻을 갖고 있습니다. (얄팍하다 라는 뜻도 있다.)</p>\\n<p>다시 말해, ‘Shallow Copy’는 <strong>객체의 복제 과정이 깊지 않음</strong>을 의미합니다.</p>\\n<p>아래의 예제를 살펴보면 Shallow Copy의 의미를 이해할 수 있습니다.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code>    <span class=\\\"token keyword\\\">let</span> originalObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> a<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">,</span> b<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>c<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">}</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">let</span> shallowCopyObj <span class=\\\"token operator\\\">=</span> Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">assign</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span> originalObj<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    \\n    shallowCopyObj<span class=\\\"token punctuation\\\">.</span>b<span class=\\\"token punctuation\\\">.</span>c <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">3</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>originalObj<span class=\\\"token punctuation\\\">.</span>b<span class=\\\"token punctuation\\\">.</span>c<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// output 3 : 복제의 원본이 되는 객체의 프로퍼티 값이 바뀐다.</span>\\n</code></pre>\\n      </div>\\n<p>‘Shallow Copy’가 진행될 때 ‘복제’하려는 값이 참조 타입인 객체이고 그 객체의 내부 프로퍼티가 ‘참조 타입’인 값이 존재하는 경우,</p>\\n<p>참조 값은 프로퍼티가 그대로 유지된 채 새로운 객체가 생성됩니다.</p>\\n<p>`Shallow Copy’가 진행되어 만들어진 복제된 객체의 프로퍼티와, 원본의 프로퍼티는 서로 같은 것을 가리키게 됩니다.</p>\\n<p>따라서 참조 타입 값을 프로퍼티로 갖고 있는 객체를 복제할 때는 </p>\\n<p>프로퍼티들도 모두 온전히 복제가 이루어져야 하는 지에 대해 한번 더 생각해 볼 필요성이 있습니다.</p>\\n<p>참조 값인 프로퍼티들 또한 복제가 이루어지는 과정을 ‘Deep Copy’라고 합니다.</p>\\n<hr>\\n<h3>Deep Copy is</h3>\\n<p>‘Deep Copy’에서 ‘Deep’은 ‘Shallow’와는 반대의 표현입니다. 즉, ‘깊다.(물리적으로)‘를 의미합니다.</p>\\n<p>그럼 ‘Deep Copy’의 과정이 ‘Shallow Copy’와 다른 점을 생각해봅시다.</p>\\n<p>‘Shallow Copy’는 복제하는 대상이 객체일 경우 새로운 객체를 만들고 그 객체가 갖고 있는 내부를 복제하는 과정을 한번만 거치며 끝이 납니다.</p>\\n<p>여기서 주목할 것은 복제하는 대상이 참조 타입인 ‘객체’임을 확인하고 객체일 경우 새로운 객체를 만드는 과정입니다.</p>\\n<p>‘Shallow Copy’는 객체인지를 확인하고 새로운 객체를 할당하는 과정을 원본 객체 자체만 거치고,</p>\\n<p>‘Deep Copy’는 원본 객체의 프로퍼티들을 모두 거친다는 차이점이 있습니다.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code>    <span class=\\\"token comment\\\">//Deep Copy의미를 clone으로 대체하여 표현하기도 있습니다. </span>\\n    <span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">cloneObject</span><span class=\\\"token punctuation\\\">(</span>obj<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">var</span> cloneObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">for</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">var</span> i <span class=\\\"token keyword\\\">in</span> obj<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>obj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">!==</span> <span class=\\\"token keyword\\\">null</span> <span class=\\\"token operator\\\">&amp;&amp;</span>  <span class=\\\"token keyword\\\">typeof</span><span class=\\\"token punctuation\\\">(</span>obj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">===</span> <span class=\\\"token string\\\">\\\"object\\\"</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                cloneObj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">cloneObject</span><span class=\\\"token punctuation\\\">(</span>obj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n                cloneObj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">=</span> obj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token keyword\\\">return</span> cloneObj<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n    <span class=\\\"token keyword\\\">let</span> originalObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> a<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">,</span> b<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>c<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">}</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">let</span> shallowCopyObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">cloneObject</span><span class=\\\"token punctuation\\\">(</span>originalObj<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    shallowCopyObj<span class=\\\"token punctuation\\\">.</span>b<span class=\\\"token punctuation\\\">.</span>c <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">3</span><span class=\\\"token punctuation\\\">;</span>\\n    \\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>originalObj<span class=\\\"token punctuation\\\">.</span>b<span class=\\\"token punctuation\\\">.</span>c<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// output 2</span>\\n</code></pre>\\n      </div>\\n<hr>\\n<h3>Component is</h3>\\n<p>React에서 컴포넌트는 어플리케이션을 구성하는 ‘단위’라고 할 수 있습니다.</p>\\n<p>예를 들어 Todo 앱을 만든다고 가정하면 여러가지 기준을 통해 어플리케이션을 나눠 컴포넌트를 관리할 수 있습니다.</p>\\n<p>React는 여러 컴포넌트들의 조합으로 어플리케이션을 만듭니다.</p>\\n<p>React의 컴포넌트들은 부모-자식 관계를 만들 수 있으며, </p>\\n<p><img src=\\\"http://blog.mgechev.com/images/overview-components/component-tree.png\\\" alt=\\\"Image\\\"></p>\\n<p>기본적인 컴포넌트는 React 라이브러리 내에 있는 <strong>Component</strong>를 상속을 통해 구현할 수 있습니다.</p>\\n<p>컴포넌트들 사이에 부모-자식 관계가 생성되면 데이터를 주고 받을 수 있으며 <strong>One-way data flow</strong>입니다.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-jsx\\\"><code><span class=\\\"token keyword\\\">import</span> React<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token punctuation\\\">{</span> Component <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">from</span> <span class=\\\"token string\\\">'react'</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">export</span> <span class=\\\"token keyword\\\">default</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Normal</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">Component</span> <span class=\\\"token punctuation\\\">{</span>\\n\\n  <span class=\\\"token function\\\">render</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">(</span>\\n      <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>div</span><span class=\\\"token punctuation\\\">></span></span>\\n        This is just Component\\n      <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>div</span><span class=\\\"token punctuation\\\">></span></span>\\n    <span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>기본적으로 부모의 컴포넌트가 Rendering 되면 자식 컴포넌트도 함께 Rendering 됩니다.</p>\\n<p>그러나 무조건적인 Rendering은 비효율적이기 때문에 React의 컴포넌트는 Rendering을 통제할 수 있는 메서드를 갖고 있습니다.</p>\\n<p><strong>shouldComponentUpdate</strong>라는 메서드를 통해 컴포넌트의 Rendering을 컨트롤할 수 있습니다.</p>\\n<p><strong>shouldComponentUpdate</strong>라는 메서드는 인자로 nextProps와 nextState를 받으며,</p>\\n<p>Return 값으로 true , false 넘기며 true, false 여부에 따라 컴포넌트를 Rendering 합니다.</p>\\n<p>React의 <strong>Component</strong>를 통해 만들어진 컴포넌트는 기본적으로 <strong>shouldComponentUpdate</strong>를 실행하지 않습니다.</p>\\n<p>그렇기 때문에 무조건적인 Rendering을 막기 위해서는 <strong>shouldComponentUpdate</strong>를 따로 구현하여 통제하거나, 컴포넌트를 재설계해야하는 과정이 필요합니다.</p>\\n<hr>\\n<h3>PureComponent is</h3>\\n<p>컴포넌트의 종류 중 <strong>PureComponent</strong>라는 것이 존재합니다.</p>\\n<p>이것은 React 라이브러리 내에 있으며 컴포넌트를 만들 때 <strong>Component</strong>대신 사용할 수 있습니다.</p>\\n<p>이 둘의 차이는 <strong>shouldComponentUpdate</strong>의 <strong>실행여부</strong> 입니다.</p>\\n<p><strong>PureComponent</strong>를 통해 컴포넌트를 만들면 컴포넌트 렌더링 시점에 <strong>shouldComponentUpdate</strong>를 실행하게 되는데,</p>\\n<p><strong>PureComponent</strong>는 props와 state를 캐싱합니다.</p>\\n<p>캐싱된 props와 state를 새로 들어온 props, state외 <strong>Shallow Comparison</strong>(얕은 비교를) 하여 Rendering 여부를 판단합니다.</p>\\n<p>Rendering 시점에서 props나 state의 변화가 없으면 컴포넌트를 Rendering 하지 않습니다.</p>\\n<p>여기서 주의해야 할 점은 <strong>Shallow Comparison</strong>(얕은 비교)이기 때문에 props와 state의 데이터 구조가 복잡한 형태일 경우,</p>\\n<p>컴포넌트의 Rendering 시점이 원하지 않는 방향으로 판단될 수 있습니다.</p>\\n<p><a href=\\\"https://reactjs.org/docs/react-api.html#reactpurecomponent\\\">참조 링크</a></p>\",\"frontmatter\":{\"date\":\"February 09, 2018\",\"path\":\"/react/pure-component\",\"title\":\"Deep Copy와 Shallow Copy, Pure Component\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---react-pure-component-5a740d22279f1b254353.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h3>Agenda</h3>\\n<ul>\\n<li>Shallow Copy와 Deep Copy</li>\\n<li>React.Component 와 React.PureComponent의 차이</li>\\n</ul>\\n<hr>\\n<h3>Shallow Copy is</h3>\\n<p>우리는 값의 ‘복제’라는 개념을 생각할 때 ‘별개의 것’이라고 예상합니다. </p>\\n<p>즉, 복제가 진행되면 복제된 대상과 원본은 서로 영향을 끼치지 않는 다는 것을 의미합니다.</p>\\n<p>‘Shallow’라는 단어의 의미는 <strong>물리적으로 두께 또는 깊이 따위가 얕다</strong>라는 뜻을 갖고 있습니다. (얄팍하다 라는 뜻도 있다.)</p>\\n<p>다시 말해, ‘Shallow Copy’는 <strong>객체의 복제 과정이 깊지 않음</strong>을 의미합니다.</p>\\n<p>아래의 예제를 살펴보면 Shallow Copy의 의미를 이해할 수 있습니다.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code>    <span class=\\\"token keyword\\\">let</span> originalObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> a<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">,</span> b<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>c<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">}</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">let</span> shallowCopyObj <span class=\\\"token operator\\\">=</span> Object<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">assign</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span> originalObj<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    \\n    shallowCopyObj<span class=\\\"token punctuation\\\">.</span>b<span class=\\\"token punctuation\\\">.</span>c <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">3</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>originalObj<span class=\\\"token punctuation\\\">.</span>b<span class=\\\"token punctuation\\\">.</span>c<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// output 3 : 복제의 원본이 되는 객체의 프로퍼티 값이 바뀐다.</span>\\n</code></pre>\\n      </div>\\n<p>‘Shallow Copy’가 진행될 때 ‘복제’하려는 값이 참조 타입인 객체이고 그 객체의 내부 프로퍼티가 ‘참조 타입’인 값이 존재하는 경우,</p>\\n<p>참조 값은 프로퍼티가 그대로 유지된 채 새로운 객체가 생성됩니다.</p>\\n<p>`Shallow Copy’가 진행되어 만들어진 복제된 객체의 프로퍼티와, 원본의 프로퍼티는 서로 같은 것을 가리키게 됩니다.</p>\\n<p>따라서 참조 타입 값을 프로퍼티로 갖고 있는 객체를 복제할 때는 </p>\\n<p>프로퍼티들도 모두 온전히 복제가 이루어져야 하는 지에 대해 한번 더 생각해 볼 필요성이 있습니다.</p>\\n<p>참조 값인 프로퍼티들 또한 복제가 이루어지는 과정을 ‘Deep Copy’라고 합니다.</p>\\n<hr>\\n<h3>Deep Copy is</h3>\\n<p>‘Deep Copy’에서 ‘Deep’은 ‘Shallow’와는 반대의 표현입니다. 즉, ‘깊다.(물리적으로)‘를 의미합니다.</p>\\n<p>그럼 ‘Deep Copy’의 과정이 ‘Shallow Copy’와 다른 점을 생각해봅시다.</p>\\n<p>‘Shallow Copy’는 복제하는 대상이 객체일 경우 새로운 객체를 만들고 그 객체가 갖고 있는 내부를 복제하는 과정을 한번만 거치며 끝이 납니다.</p>\\n<p>여기서 주목할 것은 복제하는 대상이 참조 타입인 ‘객체’임을 확인하고 객체일 경우 새로운 객체를 만드는 과정입니다.</p>\\n<p>‘Shallow Copy’는 객체인지를 확인하고 새로운 객체를 할당하는 과정을 원본 객체 자체만 거치고,</p>\\n<p>‘Deep Copy’는 원본 객체의 프로퍼티들을 모두 거친다는 차이점이 있습니다.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code>    <span class=\\\"token comment\\\">//Deep Copy의미를 clone으로 대체하여 표현하기도 있습니다. </span>\\n    <span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">cloneObject</span><span class=\\\"token punctuation\\\">(</span>obj<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">var</span> cloneObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">for</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">var</span> i <span class=\\\"token keyword\\\">in</span> obj<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>obj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">!==</span> <span class=\\\"token keyword\\\">null</span> <span class=\\\"token operator\\\">&amp;&amp;</span>  <span class=\\\"token keyword\\\">typeof</span><span class=\\\"token punctuation\\\">(</span>obj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">===</span> <span class=\\\"token string\\\">\\\"object\\\"</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                cloneObj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">cloneObject</span><span class=\\\"token punctuation\\\">(</span>obj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n                cloneObj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">=</span> obj<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token keyword\\\">return</span> cloneObj<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n    <span class=\\\"token keyword\\\">let</span> originalObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> a<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">,</span> b<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span>c<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">}</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">let</span> shallowCopyObj <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">cloneObject</span><span class=\\\"token punctuation\\\">(</span>originalObj<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    shallowCopyObj<span class=\\\"token punctuation\\\">.</span>b<span class=\\\"token punctuation\\\">.</span>c <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">3</span><span class=\\\"token punctuation\\\">;</span>\\n    \\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>originalObj<span class=\\\"token punctuation\\\">.</span>b<span class=\\\"token punctuation\\\">.</span>c<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// output 2</span>\\n</code></pre>\\n      </div>\\n<hr>\\n<h3>Component is</h3>\\n<p>React에서 컴포넌트는 어플리케이션을 구성하는 ‘단위’라고 할 수 있습니다.</p>\\n<p>예를 들어 Todo 앱을 만든다고 가정하면 여러가지 기준을 통해 어플리케이션을 나눠 컴포넌트를 관리할 수 있습니다.</p>\\n<p>React는 여러 컴포넌트들의 조합으로 어플리케이션을 만듭니다.</p>\\n<p>React의 컴포넌트들은 부모-자식 관계를 만들 수 있으며, </p>\\n<p><img src=\\\"http://blog.mgechev.com/images/overview-components/component-tree.png\\\" alt=\\\"Image\\\"></p>\\n<p>기본적인 컴포넌트는 React 라이브러리 내에 있는 <strong>Component</strong>를 상속을 통해 구현할 수 있습니다.</p>\\n<p>컴포넌트들 사이에 부모-자식 관계가 생성되면 데이터를 주고 받을 수 있으며 <strong>One-way data flow</strong>입니다.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-jsx\\\"><code><span class=\\\"token keyword\\\">import</span> React<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token punctuation\\\">{</span> Component <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">from</span> <span class=\\\"token string\\\">'react'</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">export</span> <span class=\\\"token keyword\\\">default</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Normal</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">Component</span> <span class=\\\"token punctuation\\\">{</span>\\n\\n  <span class=\\\"token function\\\">render</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">(</span>\\n      <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>div</span><span class=\\\"token punctuation\\\">></span></span>\\n        This is just Component\\n      <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>div</span><span class=\\\"token punctuation\\\">></span></span>\\n    <span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>기본적으로 부모의 컴포넌트가 Rendering 되면 자식 컴포넌트도 함께 Rendering 됩니다.</p>\\n<p>그러나 무조건적인 Rendering은 비효율적이기 때문에 React의 컴포넌트는 Rendering을 통제할 수 있는 메서드를 갖고 있습니다.</p>\\n<p><strong>shouldComponentUpdate</strong>라는 메서드를 통해 컴포넌트의 Rendering을 컨트롤할 수 있습니다.</p>\\n<p><strong>shouldComponentUpdate</strong>라는 메서드는 인자로 nextProps와 nextState를 받으며,</p>\\n<p>Return 값으로 true , false 넘기며 true, false 여부에 따라 컴포넌트를 Rendering 합니다.</p>\\n<p>React의 <strong>Component</strong>를 통해 만들어진 컴포넌트는 기본적으로 <strong>shouldComponentUpdate</strong>를 실행하지 않습니다.</p>\\n<p>그렇기 때문에 무조건적인 Rendering을 막기 위해서는 <strong>shouldComponentUpdate</strong>를 따로 구현하여 통제하거나, 컴포넌트를 재설계해야하는 과정이 필요합니다.</p>\\n<hr>\\n<h3>PureComponent is</h3>\\n<p>컴포넌트의 종류 중 <strong>PureComponent</strong>라는 것이 존재합니다.</p>\\n<p>이것은 React 라이브러리 내에 있으며 컴포넌트를 만들 때 <strong>Component</strong>대신 사용할 수 있습니다.</p>\\n<p>이 둘의 차이는 <strong>shouldComponentUpdate</strong>의 <strong>실행여부</strong> 입니다.</p>\\n<p><strong>PureComponent</strong>를 통해 컴포넌트를 만들면 컴포넌트 렌더링 시점에 <strong>shouldComponentUpdate</strong>를 실행하게 되는데,</p>\\n<p><strong>PureComponent</strong>는 props와 state를 캐싱합니다.</p>\\n<p>캐싱된 props와 state를 새로 들어온 props, state외 <strong>Shallow Comparison</strong>(얕은 비교를) 하여 Rendering 여부를 판단합니다.</p>\\n<p>Rendering 시점에서 props나 state의 변화가 없으면 컴포넌트를 Rendering 하지 않습니다.</p>\\n<p>여기서 주의해야 할 점은 <strong>Shallow Comparison</strong>(얕은 비교)이기 때문에 props와 state의 데이터 구조가 복잡한 형태일 경우,</p>\\n<p>컴포넌트의 Rendering 시점이 원하지 않는 방향으로 판단될 수 있습니다.</p>\\n<p><a href=\\\"https://reactjs.org/docs/react-api.html#reactpurecomponent\\\">참조 링크</a></p>\",\"frontmatter\":{\"date\":\"February 09, 2018\",\"path\":\"/react/pure-component\",\"title\":\"Deep Copy와 Shallow Copy, Pure Component\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/react-pure-component.json\n// module id = 319\n// module chunks = 103224921071788"],"sourceRoot":""}